const path = require('path');
const Logger = require('../utils/Logger');
const ReturnMessage = require('../models/ReturnMessage');
const Command = require('../models/Command');
const Database = require('../utils/Database');
const fs = require('fs');

const logger = new Logger('anonymous-message');
const database = Database.getInstance();

// Constantes
const COOLDOWN_HOURS = 6; // Cooldown de 12 horas
const COOLDOWN_MS = COOLDOWN_HOURS * 60 * 60 * 1000; // Cooldown em milissegundos

// Caminho para o arquivo de mensagens an√¥nimas
const ANON_MSGS_PATH = path.join(database.databasePath, 'anon-msgs.json');

/**
 * Obt√©m as mensagens an√¥nimas armazenadas
 * @returns {Array} - Lista de mensagens an√¥nimas
 */
function getAnonMessages() {
  try {
    if (!fs.existsSync(ANON_MSGS_PATH)) {
      // Se o arquivo n√£o existir, cria com um array vazio
      fs.writeFileSync(ANON_MSGS_PATH, JSON.stringify([], null, 2), 'utf8');
      return [];
    }
    
    const data = fs.readFileSync(ANON_MSGS_PATH, 'utf8');
    return JSON.parse(data || '[]');
  } catch (error) {
    logger.error('Erro ao carregar mensagens an√¥nimas:', error);
    return [];
  }
}

/**
 * Salva as mensagens an√¥nimas no arquivo
 * @param {Array} messages - Lista de mensagens an√¥nimas
 * @returns {boolean} - Status de sucesso
 */
function saveAnonMessages(messages) {
  try {
    // Limita o hist√≥rico a 100 mensagens, mantendo as mais recentes
    if (messages.length > 100) {
      messages = messages.slice(-100);
    }
    
    // Cria diret√≥rio se n√£o existir
    const dir = path.dirname(ANON_MSGS_PATH);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    // Use sistema de escrita segura
    const tempFilePath = `${ANON_MSGS_PATH}.temp`;
    fs.writeFileSync(tempFilePath, JSON.stringify(messages, null, 2), 'utf8');
    
    // Verifica se a escrita foi bem-sucedida
    try {
      const testRead = fs.readFileSync(tempFilePath, 'utf8');
      JSON.parse(testRead); // Verifica se √© JSON v√°lido
    } catch (readError) {
      logger.error(`Erro na verifica√ß√£o do arquivo tempor√°rio:`, readError);
      if (fs.existsSync(tempFilePath)) {
        fs.unlinkSync(tempFilePath);
      }
      return false;
    }
    
    // Renomeia o arquivo tempor√°rio para o arquivo final
    if (fs.existsSync(ANON_MSGS_PATH)) {
      fs.unlinkSync(ANON_MSGS_PATH);
    }
    fs.renameSync(tempFilePath, ANON_MSGS_PATH);
    
    return true;
  } catch (error) {
    logger.error('Erro ao salvar mensagens an√¥nimas:', error);
    return false;
  }
}

/**
 * Verifica o cooldown de um usu√°rio
 * @param {string} userId - ID do usu√°rio
 * @returns {object} - Objeto com status e tempo restante em horas
 */
function checkUserCooldown(userId, targetGroup) {
  const messages = getAnonMessages();
  const now = Date.now();
  
  // Encontra a mensagem mais recente do usu√°rio
  const lastMessage = messages
    .filter(msg => msg.senderId === userId && msg.targetGroupName.toLowerCase() === targetGroup.toLowerCase())
    .sort((a, b) => b.timestamp - a.timestamp)[0];
  
  if (!lastMessage) {
    return { onCooldown: false, timeLeft: 0 };
  }
  
  const timeSinceLastMessage = now - lastMessage.timestamp;
  
  if (timeSinceLastMessage < COOLDOWN_MS) {
    const timeLeft = Math.ceil((COOLDOWN_MS - timeSinceLastMessage) / (1000 * 60 * 60));
    return { onCooldown: true, timeLeft };
  }
  
  return { onCooldown: false, timeLeft: 0 };
}

/**
 * Envia uma mensagem an√¥nima para um grupo
 * @param {WhatsAppBot} bot - Inst√¢ncia do bot
 * @param {Object} message - Dados da mensagem
 * @param {Array} args - Argumentos do comando
 * @param {Object} group - Dados do grupo
 * @returns {Promise<ReturnMessage>} Mensagem de retorno
 */
async function anonymousMessage(bot, message, args, group) {
  try {
    // Verifica o ID do remetente
    const senderId = message.author;
    
    // Verifica se h√° argumentos suficientes
    if (args.length < 2) {
      return new ReturnMessage({
        chatId: senderId,
        content: `‚ö†Ô∏è Formato incorreto. Use: !anonimo ${group.name} mensagem\n\nExemplo: !anonimo ${group.name} Ol√°, esta √© uma mensagem an√¥nima!`
      });
    }
    
    // Obt√©m o ID do grupo alvo
    const targetGroupName = args[0].toLowerCase();

    // Verifica cooldown
    const cooldownCheck = checkUserCooldown(senderId, targetGroupName);
    if (cooldownCheck.onCooldown) {
      return new ReturnMessage({
        chatId: senderId,
        content: `‚è≥ Voc√™ precisa esperar ${cooldownCheck.timeLeft} hora(s) para enviar outra mensagem an√¥nima.`
      });
    }
    
    
    // Obt√©m a mensagem a ser enviada
    const anonymousText = args.slice(1).join(' ');
    
    // Verifica se a mensagem √© muito curta
    if (anonymousText.length < 5) {
      return new ReturnMessage({
        chatId: senderId,
        content: '‚ö†Ô∏è A mensagem √© muito curta. Por favor, escreva algo mais substancial.'
      });
    }
    
    // Obt√©m todos os grupos para verificar o alvo
    const groups = await database.getGroups();
    
    // Encontra o grupo pelo nome ou ID
    const targetGroup = groups.find(g => 
      (g.name && g.name.toLowerCase() === targetGroupName) || 
      (g.id && g.id.toLowerCase().includes(targetGroupName))
    );
    
    if (!targetGroup) {
      return new ReturnMessage({
        chatId: senderId,
        content: `‚ùå Grupo "${targetGroupName}" n√£o encontrado. Verifique o nome e tente novamente.`
      });
    }
    
    // Verifica se o grupo existe e se o bot est√° no grupo
    try {
      const chat = await bot.client.getChatById(targetGroup.id);
      
      // Verifica se o usu√°rio est√° no grupo (OBRIGAT√ìRIO)
      const participants = await chat.participants;
      const isUserInGroup = participants.some(p => p.id._serialized === senderId);
      
      if (!isUserInGroup) {
        return new ReturnMessage({
          chatId: senderId,
          content: `‚ùå Voc√™ n√£o √© membro do grupo "${targetGroup.name}". Apenas membros podem enviar mensagens an√¥nimas para este grupo.`
        });
      }
    } catch (error) {
      logger.error('Erro ao verificar grupo ou participantes:', error);
      return new ReturnMessage({
        chatId: senderId,
        content: `‚ùå N√£o foi poss√≠vel acessar o grupo. O bot pode n√£o estar mais nele ou o grupo foi exclu√≠do.`
      });
    }
    
    // Registra a mensagem an√¥nima
    const now = Date.now();
    const anonMessages = getAnonMessages();
    
    // Adiciona nova mensagem ao registro
    anonMessages.push({
      senderId,
      targetGroupId: targetGroup.id,
      targetGroupName: targetGroup.name,
      message: anonymousText,
      timestamp: now
    });
    
    // Salva as mensagens atualizadas
    saveAnonMessages(anonMessages);
    
    // Envia a mensagem para o grupo alvo
    try {
      // Formata a mensagem an√¥nima
      const formattedMessage = `üëª *Um membro an√¥nimo enviou:*\n\n> ${anonymousText}`;
      
      // Envia para o grupo alvo
      await bot.sendMessage(targetGroup.id, formattedMessage);
      
      // Confirma o envio para o remetente
      return new ReturnMessage({
        chatId: senderId,
        content: `‚úÖ Sua mensagem an√¥nima foi enviada com sucesso para o grupo "${targetGroup.name}".\n\nVoc√™ poder√° enviar outra mensagem an√¥nima em ${COOLDOWN_HOURS} horas.`
      });
    } catch (error) {
      logger.error('Erro ao enviar mensagem an√¥nima:', error);
      
      return new ReturnMessage({
        chatId: senderId,
        content: `‚ùå Erro ao enviar mensagem an√¥nima: ${error.message}`
      });
    }
  } catch (error) {
    logger.error('Erro no comando de mensagem an√¥nima:', error);
    
    return new ReturnMessage({
      chatId: message.author,
      content: '‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Por favor, tente novamente.'
    });
  }
}

/**
 * Adiciona comandos administrativos para gerenciar mensagens an√¥nimas
 * @param {WhatsAppBot} bot - Inst√¢ncia do bot
 * @param {Object} message - Dados da mensagem
 * @param {Array} args - Argumentos do comando
 * @returns {Promise<ReturnMessage>} Mensagem de retorno
 */
async function adminAnonMessages(bot, message, args) {
  try {
    // Verifica se √© um administrador do bot
    const isAdmin = await bot.isAdmin(message.author);
    if (!isAdmin) {
      return new ReturnMessage({
        chatId: message.author,
        content: `‚õî Apenas administradores podem usar este comando.`
      });
    }
    
    // Obt√©m as mensagens an√¥nimas
    const anonMessages = getAnonMessages();
    
    if (args.length === 0 || args[0] === 'list') {
      // Lista as √∫ltimas 10 mensagens an√¥nimas
      if (anonMessages.length === 0) {
        return new ReturnMessage({
          chatId: message.author,
          content: `üìù N√£o h√° mensagens an√¥nimas registradas.`
        });
      }
      
      const lastMessages = anonMessages
        .slice(-10)
        .map((msg, index) => {
          const date = new Date(msg.timestamp).toLocaleString('pt-BR');
          return `*${index + 1}.* De: ${msg.senderId}\nPara: ${msg.targetGroupName}\nData: ${date}\nMensagem: "${msg.message}"`;
        })
        .join('\n\n');
      
      return new ReturnMessage({
        chatId: message.author,
        content: `üìù *√öltimas mensagens an√¥nimas:*\n\n${lastMessages}`
      });
    } else if (args[0] === 'clear') {
      // Limpa todas as mensagens an√¥nimas
      saveAnonMessages([]);
      
      return new ReturnMessage({
        chatId: message.author,
        content: `üßπ Todas as mensagens an√¥nimas foram removidas.`
      });
    } else if (args[0] === 'find' && args.length > 1) {
      // Busca mensagens por ID do usu√°rio
      const userId = args[1];
      const userMessages = anonMessages.filter(msg => msg.senderId.includes(userId));
      
      if (userMessages.length === 0) {
        return new ReturnMessage({
          chatId: message.author,
          content: `üîç Nenhuma mensagem encontrada para o usu√°rio ${userId}.`
        });
      }
      
      const formattedMessages = userMessages
        .slice(-5) // Apenas as 5 mais recentes
        .map((msg, index) => {
          const date = new Date(msg.timestamp).toLocaleString('pt-BR');
          return `*${index + 1}.* Para: ${msg.targetGroupName}\nData: ${date}\nMensagem: "${msg.message}"`;
        })
        .join('\n\n');
      
      return new ReturnMessage({
        chatId: message.author,
        content: `üîç *Mensagens do usu√°rio ${userId}:*\n\n${formattedMessages}`
      });
    }
    
    // Instru√ß√µes para o comando
    return new ReturnMessage({
      chatId: message.author,
      content: `üìã *Comandos dispon√≠veis:*\n\n` +
        `!adminanon list - Lista as √∫ltimas mensagens an√¥nimas\n` +
        `!adminanon find [id] - Busca mensagens por ID do usu√°rio\n` +
        `!adminanon clear - Remove todas as mensagens an√¥nimas`
    });
  } catch (error) {
    logger.error('Erro no comando adminAnon:', error);
    
    return new ReturnMessage({
      chatId: message.author,
      content: '‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.'
    });
  }
}

// Criar comandos
const commands = [
  new Command({
    name: 'anonimo',
    description: 'Envia uma mensagem an√¥nima para um grupo',
    category: "jogos",
    cooldown: 0, // O cooldown √© gerenciado internamente
    reactions: {
      before: "üëª",
      after: "üì®",
      error: "‚ùå"
    },
    method: anonymousMessage
  }),
  new Command({
    name: 'an√¥nimo',
    description: 'Envia uma mensagem an√¥nima para um grupo',
    category: "jogos",
    hidden: true,
    cooldown: 0, // O cooldown √© gerenciado internamente
    reactions: {
      before: "üëª",
      after: "üì®",
      error: "‚ùå"
    },
    method: anonymousMessage
  }),
  new Command({
    name: 'adminanon',
    description: 'Gerencia mensagens an√¥nimas (apenas admin)',
    category: "admin",
    hidden: true,
    cooldown: 0,
    reactions: {
      before: "üîç",
      after: "üìã",
      error: "‚ùå"
    },
    method: adminAnonMessages
  })
];

module.exports = { commands };